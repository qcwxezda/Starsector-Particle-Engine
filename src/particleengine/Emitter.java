package particleengine;

import com.fs.starfarer.api.graphics.SpriteAPI;
import com.fs.starfarer.api.util.Misc;
import org.lwjgl.BufferUtils;
import org.lwjgl.util.vector.Vector2f;

import java.awt.*;
import java.nio.FloatBuffer;

/**
 * A particle generator.
 * Initialize an {@code Emitter} using {@link Particles#initialize}. After setting the emitter's properties,
 * generate particles using {@link Particles#burst} or {@link Particles#stream}.
 */
public class Emitter {
    final int sfactor, dfactor, blendMode;
    final SpriteAPI sprite;
    float minLife = 1f, maxLife = 1f;

    final Vector2f location = new Vector2f();
    final Vector2f
            minOffset = new Vector2f(),
            maxOffset = new Vector2f(),
            minVelocity = new Vector2f(),
            maxVelocity = new Vector2f(),
            minAcceleration = new Vector2f(),
            maxAcceleration = new Vector2f();
    /**
     * Random point in circle of radius positionSpread is added to position. Same for velocity and acceleration.
     */
    float positionSpread = 0f, velocitySpread = 0f, accelerationSpread = 0f;
    /**
     * Alpha is angular acceleration, NOT image alpha
     */
    float minTheta = 0f, maxTheta = 0f, minW = 0f, maxW = 0f, minAlpha = 0f, maxAlpha = 0f;
    final float[]
            minSizeDataX = new float[] {25f, 0f, 0f},
            maxSizeDataX = new float[] {25f, 0f, 0f},
            minSizeDataY = new float[] {25f, 0f, 0f},
            maxSizeDataY = new float[] {25f, 0f, 0f};
    float minFadeIn = 0.1f, maxFadeIn = 0.1f, minFadeOut = 0.1f, maxFadeOut = 0.1f;
    /** All color data in hsva */
    final float[]
            startColor = new float[] {0f, 0f, 1f, 1f},
            startColorRandom = new float[] {0f, 0f, 0f, 0f},
            minColorShift = new float[] {0f, 0f, 0f, 0f},
            maxColorShift = new float[] {0f, 0f, 0f, 0f};
    /**
     * Velocity and acceleration amounts pointed outwards. No effect if positionSpread is 0.
     */
    float minRadialVelocity = 0f, maxRadialVelocity = 0f, minRadialAcceleration = 0f, maxRadialAcceleration = 0f;
    float minRadialW = 0f, maxRadialW = 0f, minRadialAlpha = 0f, maxRadialAlpha = 0f;
    float minSinXAmplitude = 0f, maxSinXAmplitude = 0f, minSinXFrequency = 0f, maxSinXFrequency = 0f, minSinXPhase = 0f, maxSinXPhase = 0f;
    float minSinYAmplitude = 0f, maxSinYAmplitude = 0f, minSinYFrequency = 0f, maxSinYFrequency = 0f, minSinYPhase = 0f, maxSinYPhase = 0f;
    final Vector2f xAxis = new Vector2f(1f, 0f);

    Emitter(
            Vector2f location,
            SpriteAPI sprite,
            int sfactor,
            int dfactor,
            int blendMode) {
        this.location.set(location);
        this.sfactor = sfactor; // blending
        this.dfactor = dfactor; // blending
        this.blendMode = blendMode; // blending
        this.sprite = sprite;
    }

    /**
     * Sets the minimum and maximum lifetime of particles generated by this {@code Emitter}.
     * Particles exceeding their lifespan are not rendered.
     *
     * @param minLife Minimum lifetime, in seconds.
     * @param maxLife Maximum lifetime, in seconds.
     */
    public void life(float minLife, float maxLife) {
        this.minLife = minLife;
        this.maxLife = maxLife;
    }


    /**
     * Sets the fade-in and fade-out times for particles generated by this emitter. Particles' alpha values rise linearly from
     * {@code 0} to {@code 1} within the fade-in window, and fall linearly from {@code 1} to {@code 0} within
     * the fade-out window.
     *
     * @param minFadeIn  Minimum fade-in time, in seconds.
     * @param maxFadeIn  Maximum fade-in time, in seconds.
     * @param minFadeOut Minimum fade-out time, in seconds.
     * @param maxFadeOut Maximum fade-out time, in seconds.
     */
    public void fadeTime(float minFadeIn, float maxFadeIn, float minFadeOut, float maxFadeOut) {
        this.minFadeIn = minFadeIn;
        this.minFadeOut = minFadeOut;
        this.maxFadeIn = maxFadeIn;
        this.maxFadeOut = maxFadeOut;
    }

    /**
     * Sets this emitter's location. To set the starting position of particles relative to this emitter,
     * use {@link Emitter#offset}.
     *
     * @param x Initial x-position, in absolute world units.
     * @param y Initial y-position, in absolute world units.
     */
    public void setLocation(float x, float y) {
        this.location.set(x, y);
    }

    /** @see Emitter#setLocation(float, float) */
    public void setLocation(Vector2f location) {
        this.location.set(location);
    }

    /**
     * Sets the position of generated particles relative to this emitter's location. This position is defined
     * along the emitter's axes.
     *
     * @param minX Minimum offset of particles along the emitter's x-axis in world units.
     * @param maxX Maximum offset of particles along the emitter's x-axis in world units.
     * @param minY Minimum offset of particles along the emitter's y-axis in world units.
     * @param maxY Maximum offset of particles along the emitter's y-axis in world units.
     */
    public void offset(float minX, float maxX, float minY, float maxY) {
        this.minOffset.set(new Vector2f(minX, minY));
        this.maxOffset.set(new Vector2f(maxX, maxY));
    }

    /**
     *  Sets the component-wise minimum and maximum positions of generated particles relative to this emitter's location,
     *  along the emitter's axes.
     *
     * @param min Minimum x and y offsets.
     * @param max Maximum x and y offsets.
     */
    public void offset(Vector2f min, Vector2f max) {
        this.minOffset.set(min);
        this.maxOffset.set(max);
    }

    /**
     * Sets the velocity of generated particles along the emitter's axes.
     *
     * @param minX Minimum velocity of particles along the emitter's x-axis in world units / s.
     * @param maxX Maximum velocity of particles along the emitter's x-axis in world units / s.
     * @param minY Minimum velocity of particles along the emitter's y-axis in world units / s.
     * @param maxY Maximum velocity of particles along the emitter's y-axis in world units / s.
     */
    public void velocity(float minX, float maxX, float minY, float maxY) {
        this.minVelocity.set(new Vector2f(minX, minY));
        this.maxVelocity.set(new Vector2f(maxX, maxY));
    }

    /**
     *  Sets the component-wise minimum and maximum velocities of generated particles along the emitter's axes.
     *
     * @param min Minimum x and y velocities.
     * @param max Maximum x and y velocities.
     */
    public void velocity(Vector2f min, Vector2f max) {
        this.minVelocity.set(min);
        this.maxVelocity.set(max);
    }

    /**
     * Sets the acceleration of generated particles along the emitter's axes.
     *
     * @param minX Minimum acceleration of particles along the emitter's x-axis in world units / s^2.
     * @param maxX Maximum acceleration of particles along the emitter's x-axis in world units / s^2.
     * @param minY Minimum acceleration of particles along the emitter's y-axis in world units / s^2.
     * @param maxY Maximum acceleration of particles along the emitter's y-axis in world units / s^2.
     */
    public void acceleration(float minX, float maxX, float minY, float maxY) {
        this.minAcceleration.set(new Vector2f(minX, minY));
        this.maxAcceleration.set(new Vector2f(maxX, maxY));
    }

    /**
     *  Sets the component-wise minimum and maximum accelerations of generated particles along the emitter's axes.
     *
     * @param min Minimum x and y accelerations.
     * @param max Maximum x and y accelerations.
     */
    public void acceleration(Vector2f min, Vector2f max) {
        this.minAcceleration.set(min);
        this.maxAcceleration.set(max);
    }

    /** Sets the axes of this emitter's coordinate system.
     *  Defaults to global axes, i.e. {@code (0, 1)} and {@code (1, 0)}.
     *
     * @param xAxis The emitter's x-axis. Doesn't need to be normalized. If degenerate, will be set to the default
     *              value {@code (0, 1)}. The emitter's y-axis will automatically be set to the
     *              unit vector that is counterclockwise perpendicular to {@code xAxis}.
     */
    public void setAxis(Vector2f xAxis) {
        if (xAxis.lengthSquared() <= 0f) {
            this.xAxis.set(1f, 0f);
            return;
        }
        xAxis.normalise(this.xAxis);
    }

    /** @see Emitter#setAxis(Vector2f) */
    public void setAxis(float dir) {
        xAxis.set(Misc.getUnitVectorAtDegreeAngle(dir));
    }

    /**
     * Adds circular randomness to the positions of particles generated by this emitter. Generated particles will have a random
     * vector inside a circle of radius {@code spread} added to their position.
     *
     * @param spread Maximum radius of circle inside which a random vector will be chosen to be added to
     *                       each particle's starting position. This vector varies per particle.
     */
    public void circularPositionSpread(float spread) {
        this.positionSpread = spread;
    }

    /**
     * Adds circular randomness to the velocities of particles generated by this emitter. Generated particles will have a random
     * vector inside a circle of radius {@code spread} added to their velocity.
     *
     * @param spread Maximum radius of circle inside which a random vector will be chosen to be added to
     *                       each particle's starting velocity. This vector varies per particle.
     */
    public void circularVelocitySpread(float spread) {
        this.velocitySpread = spread;
    }

    /**
     * Adds circular randomness to the accelerations of particles generated by this emitter. Generated particles will have a random
     * vector inside a circle of radius {@code spread} added to their acceleration.
     *
     * @param spread Maximum radius of circle inside which a random vector will be chosen to be added to
     *                       each particle's acceleration. This vector varies per particle.
     */
    public void circularAccelerationSpread(float spread) {
        this.accelerationSpread = spread;
    }

    /** Sets minimum and maximum initial facing angles of particles generated by this emitter.
     *  Each particle will have an initial facing randomly chosen between the two given angles. A
     *  facing direction of {@code 0} is oriented along this emitter's x-axis.
     *
     * @param minAngle Minimum initial facing direction, in degrees.
     * @param maxAngle Maximum initial facing direction, in degrees.
     */
    public void facing(float minAngle, float maxAngle) {
        minTheta = minAngle;
        maxTheta = maxAngle;
    }

    /** Sets minimum and maximum initial turn rates for particles generated by this emitter. Each particle will
     *  have an initial turn rate randomly chosen between the two given numbers.
     * @param minRate Minimum initial turn rate, in degrees / s.
     * @param maxRate Maximum initial turn rate, in degrees / s.
     */
    public void turnRate(float minRate, float maxRate) {
        minW = minRate;
        maxW = maxRate;
    }

    /** Sets minimum and maximum turn rate accelerations for particles generated by this emitter. Each particle will have
     * a turn rate acceleration randomly chosen between the two given numbers.
      * @param minAcceleration Minimum initial turn rate acceleration, in degrees / s^2.
     * @param maxAcceleration Maximum initial turn rate acceleration, in degrees / s^2.
     */
    public void turnAcceleration(float minAcceleration, float maxAcceleration) {
        minAlpha = minAcceleration;
        maxAlpha = maxAcceleration;
    }

    /**
     * Sets the size of particles generated by this emitter. Each particle is given a size randomly chosen between
     * {@code minSize} and {@code maxSize}.
     *
     * @param minSize Minimum initial particle size, in world units.
     * @param maxSize Maximum initial particle size, in world units.
     */
    public void size(float minSize, float maxSize) {
        minSizeDataX[0] = minSizeDataY[0] = minSize;
        maxSizeDataX[0] = maxSizeDataY[0] = maxSize;
    }

    /**
     * Sets the initial growth rate of particles generated by this emitter. Each particle is given
     * a growth rate randomly chosen between {@code minRate} and {@code maxRate}.
     *
     * @param minRate Minimum initial particle growth rate, in world units / s.
     * @param maxRate Maximum initial particle growth rate, in world units / s.
     */
    public void growthRate(float minRate, float maxRate) {
        minSizeDataX[1] = minSizeDataY[1] = minRate;
        maxSizeDataX[1] = maxSizeDataY[1] = maxRate;
    }

    /**
     * Sets the growth acceleration of particles generated by this emitter. Each particle is
     * given a growth acceleration randomly chosen between {@code minAcceleration} and {@code maxAcceleration}.
     *
     * @param minAcceleration Minimum particle growth acceleration, in world units / s^2.
     * @param maxAcceleration Maximum particle growth acceleration, in world units / s^2.
     */
    public void growthAcceleration(float minAcceleration, float maxAcceleration) {
        minSizeDataX[2] = minSizeDataY[2] = minAcceleration;
        maxSizeDataX[2] = maxSizeDataY[2] = maxAcceleration;
    }

    /** Same as {@link Emitter#size(float, float)}, but allows specification of x-scale and y-scale separately. */
    public void size(float minXSize, float maxXSize, float minYSize, float maxYSize) {
        minSizeDataX[0] = minXSize;
        maxSizeDataX[0] = maxXSize;
        minSizeDataY[0] = minYSize;
        maxSizeDataY[0] = maxYSize;
    }

    /** Same as {@link Emitter#growthRate(float, float)}, but allows specification of x-scale and y-scale separately. */
    public void growthRate(float minXRate, float maxXRate, float minYRate, float maxYRate) {
        minSizeDataX[1] = minXRate;
        maxSizeDataX[1] = maxXRate;
        minSizeDataY[1] = minYRate;
        maxSizeDataY[1] = maxYRate;
    }

    /** Same as {@link Emitter#growthAcceleration(float, float)}, but allows specification of x-scale and y-scale separately. */
    public void growthAcceleration(float minXAcceleration, float maxXAcceleration, float minYAcceleration, float maxYAcceleration) {
        minSizeDataX[2] = minXAcceleration;
        maxSizeDataX[2] = maxXAcceleration;
        minSizeDataY[2] = minYAcceleration;
        maxSizeDataY[2] = maxYAcceleration;
    }

    /**
     * Sets the initial color of particles generated by this emitter.
     * @param r Initial red value, between 0 and 1.
     * @param g Initial green value, between 0 and 1.
     * @param b Initial blue value, between 0 and 1.
     * @param a Initial alpha value, between 0 and 1.
     */
    public void color(float r, float g, float b, float a) {
        Utils.toHSVA(new float[] {r, g, b, a}, startColor);
    }

    /** @see Emitter#color(float, float, float, float) */
    public void color(Color color) {
        float[] rgba = color.getComponents(null);
        Utils.toHSVA(rgba, startColor);
    }
    
    /** @see Emitter#color(float, float, float, float) */
    public void color(float[] rgba) {
        Utils.toHSVA(rgba, startColor);
    }

    /**
     * Randomizes the initial color of particles generated by this emitter. Each particle has its initial hue modified
     * by a number in the range {@code [-h/2, h/2]}. The particle's other hsva channels are similarly randomized.
     * Resulting hue values outside {@code [0, 360)}
     * wrap around. Resulting saturation, value, and alpha values are clamped to {@code [0, 1]}.
     *
     * @param h Hue randomization, in degrees. Hue is between {@code 0} and {@code 360}.
     * @param s Saturation randomization. Saturation is between {@code 0} and {@code 1}.
     * @param v Value randomization. Value is between {@code 0} and {@code 1}.
     * @param a Alpha randomization. Alpha is between {@code 0} and {@code 1}.
     */
    public void randomColor(float h, float s, float v, float a) {
        startColorRandom[0] = h;
        startColorRandom[1] = s;
        startColorRandom[2] = v;
        startColorRandom[3] = a;
    }

    /** @see Emitter#randomColor(float, float, float, float) */
    public void randomColor(float[] hsva) {
        startColorRandom[0] = hsva[0];
        startColorRandom[1] = hsva[1];
        startColorRandom[2] = hsva[2];
        startColorRandom[3] = hsva[3];
    }

    /**
     * Adds color shift to particles, allowing individual particles to change color over time. If the resulting
     * hue value falls outside {@code [0, 360)}, it will wrap around. Resulting saturation, value, and alpha values
     * are clamped to {@code [0, 1]}.
     *
     * @param h Hue shift per second, in degrees
     * @param s Saturation shift per second
     * @param v Value shift per second
     * @param a Alpha shift per second
     */
    public void hsvaShift(float h, float s, float v, float a) {
        minColorShift[0] = maxColorShift[0] = h;
        minColorShift[1] = maxColorShift[1] = s;
        minColorShift[2] = maxColorShift[2] = v;
        minColorShift[3] = maxColorShift[3] = a;
    }
    
    /** @see Emitter#hsvaShift(float, float, float, float) */
    public void hsvaShift(float[] hsva) {
        minColorShift[0] = maxColorShift[0] = hsva[0];
        minColorShift[1] = maxColorShift[1] = hsva[1];
        minColorShift[2] = maxColorShift[2] = hsva[2];
        minColorShift[3] = maxColorShift[3] = hsva[3];
    }

    /**
     * Adds color shift to particles, allowing individual particles to change color over time.
     * Each particle is given a random hue velocity between {@code minH} and {@code maxH},
     * a random saturation velocity between {@code minS} and {@code maxS},
     * a random value velocity between {@code minV} and {@code maxV},
     * and a random alpha velocity between {@code minA} and {@code maxA}.
     * If the resulting hue value falls outside {@code [0, 360)}, it will wrap around. Resulting saturation, value, and alpha values
     * are clamped to {@code [0, 1]}.
     *
     * @param minH Minimum hue shift per second, in degrees
     * @param maxH Maximum hue shift per second, in degrees
     * @param minS Minimum saturation shift per second
     * @param maxS Maximum saturation shift per second
     * @param minV Minimum value shift per second
     * @param maxV Maximum value shift per second
     * @param minA Minimum alpha shift per second
     * @param maxA Maximum alpha shift per second
     */
    public void hsvaShift(float minH, float maxH, float minS, float maxS, float minV, float maxV, float minA, float maxA) {
        minColorShift[0] = minH;
        minColorShift[1] = minS;
        minColorShift[2] = minV;
        minColorShift[3] = minA;
        maxColorShift[0] = maxH;
        maxColorShift[1] = maxS;
        maxColorShift[2] = maxV;
        maxColorShift[3] = maxA;
    }

    /** @see Emitter#hsvaShift(float, float, float, float, float, float, float, float) */
    public void hsvaShift(float[] minHSVA, float[] maxHSVA) {
        minColorShift[0] = minHSVA[0];
        minColorShift[1] = minHSVA[1];
        minColorShift[2] = minHSVA[2];
        minColorShift[3] = minHSVA[3];
        maxColorShift[0] = maxHSVA[0];
        maxColorShift[1] = maxHSVA[1];
        maxColorShift[2] = maxHSVA[2];
        maxColorShift[3] = maxHSVA[3];
    }

    /** @see Emitter#hsvaShift(float, float, float, float, float, float, float, float) */
    public void hueShift(float minH, float maxH) {
        minColorShift[0] = minH;
        maxColorShift[0] = maxH;
    }

    /** @see Emitter#hsvaShift(float, float, float, float, float, float, float, float) */
    public void saturationShift(float minS, float maxS) {
        minColorShift[1] = minS;
        maxColorShift[1]=  maxS;
    }

    /** @see Emitter#hsvaShift(float, float, float, float, float, float, float, float) */
    public void colorValueShift(float minV, float maxV) {
        minColorShift[2] = minV;
        maxColorShift[2] = maxV;
    }

    /** @see Emitter#hsvaShift(float, float, float, float, float, float, float, float) */
    public void alphaShift(float minA, float maxA) {
        minColorShift[3] = minA;
        maxColorShift[3] = maxA;
    }

    /**
     * Adds velocity in the direction from the emitter's {@code location} to each individual particle's randomized position.
     * This effect causes particles to be pushed outwards from the emitter's {@code location}.
     * No effect on emitters with no {@code offset} or {@code positionSpread}.
     *
     * @param minVelocity Minimum outward radial velocity, in world units / s.
     * @param maxVelocity Maximum outward radial velocity, in world units / s.
     */
    public void radialVelocity(float minVelocity, float maxVelocity) {
        this.minRadialVelocity = minVelocity;
        this.maxRadialVelocity = maxVelocity;
    }

    /**
     * Adds acceleration in the direction from the emitter's {@code location} to each individual particle's randomized position.
     *
     * @param minAcceleration Minimum outward radial acceleration, in world units / s^2.
     * @param maxAcceleration Maximum outward radial acceleration, in world units / s^2.
     * @see Emitter#radialVelocity(float, float)
     */
    public void radialAcceleration(float minAcceleration, float maxAcceleration) {
        this.minRadialAcceleration = minAcceleration;
        this.maxRadialAcceleration = maxAcceleration;
    }

    /**
     * Causes particles to revolve around the emitter's {@code location} at the time of generation. In particular,
     * updates to the emitter's location after a particle has already been generated are not received.
     * This effect is applied after all other movement effects.
     *
     * @param minRate     Minimum initial revolution velocity, in degrees / s.
     * @param maxRate     Maximum initial revolution velocity, in degrees / s.
     * @param minAcceleration Minimum revolution acceleration, in degrees / s^2.
     * @param maxAcceleration Maximum revolution acceleration, in degrees / s^2.
     */
    public void radialRevolution(float minRate, float maxRate, float minAcceleration, float maxAcceleration) {
        this.minRadialW = minRate;
        this.maxRadialW = maxRate;
        this.minRadialAlpha = minAcceleration;
        this.maxRadialAlpha = maxAcceleration;
    }

    /**
     * Adds periodic motion along the emitter's x-axis. For each particle, if its phase is non-zero, will also
     * translate that particle so that its initial position is unchanged at {@code t = 0}.
     *
     * @param minAmplitude Minimum amplitude of periodic motion along the emitter's x-axis, in world units.
     * @param maxAmplitude Maximum amplitude of periodic motion along the emitter's x-axis, in world units.
     * @param minFrequency Minimum number of complete cycles per second along the emitter's x-axis.
     * @param maxFrequency Maximum of complete cycles per second along the emitter's x-axis.
     * @param minPhase     Minimum initial phase of periodic motion along the emitter's x-axis, in degrees.
     * @param maxPhase     Maximum initial phase of periodic motion along the emitter's x-axis, in degrees.
     */
    public void sinusoidalMotionX(float minAmplitude, float maxAmplitude, float minFrequency, float maxFrequency, float minPhase, float maxPhase) {
        this.minSinXAmplitude = minAmplitude;
        this.maxSinXAmplitude = maxAmplitude;
        this.minSinXFrequency = minFrequency;
        this.maxSinXFrequency = maxFrequency;
        this.minSinXPhase = minPhase;
        this.maxSinXPhase = maxPhase;
    }

    /**
     * @param minAmplitude Minimum amplitude of periodic motion along the emitter's y-axis, in world units.
     * @param maxAmplitude Maximum amplitude of periodic motion along the emitter's  y-axis, in world units.
     * @param minFrequency Minimum number of complete cycles per second along the emitter's y-axis.
     * @param maxFrequency Maximum of complete cycles per second along the emitter's y-axis.
     * @param minPhase     Minimum initial phase of periodic motion along the emitter's y-axis, in degrees.
     * @param maxPhase     Maximum initial phase of periodic motion along the emitter's y-axis, in degrees.
     * @see Emitter#sinusoidalMotionX(float, float, float, float, float, float)
     */
    public void sinusoidalMotionY(float minAmplitude, float maxAmplitude, float minFrequency, float maxFrequency, float minPhase, float maxPhase) {
        this.minSinYAmplitude = minAmplitude;
        this.maxSinYAmplitude = maxAmplitude;
        this.minSinYFrequency = minFrequency;
        this.maxSinYFrequency = maxFrequency;
        this.minSinYPhase = minPhase;
        this.maxSinYPhase = maxPhase;
    }

    FloatBuffer generate(int count, float startTime) {
        FloatBuffer buffer = BufferUtils.createFloatBuffer(count * Particles.FLOATS_PER_PARTICLE);
        float twoPi = 2f * (float) Math.PI;
        float emitterAngle = Misc.getAngleInDegrees(xAxis) * Misc.RAD_PER_DEG;

        for (int i = 0; i < count; i++) {
            Vector2f newPos = new Vector2f(
                    Utils.randBetween(minOffset.x, maxOffset.x),
                    Utils.randBetween(minOffset.y, maxOffset.y));
            Vector2f.add(newPos, location, newPos);
            Vector2f.add(newPos, Utils.randomPointInCircle(new Vector2f(), positionSpread), newPos);
            Vector2f radialDir = Misc.getDiff(newPos, location);

            Vector2f newVel = new Vector2f(
                    Utils.randBetween(minVelocity.x, maxVelocity.x),
                    Utils.randBetween(minVelocity.y, maxVelocity.y));
            Vector2f.add(newVel, Utils.randomPointInCircle(new Vector2f(), velocitySpread), newVel);
            if (radialDir.lengthSquared() > 0f) {
                radialDir.normalise();
                radialDir.scale(Utils.randBetween(minRadialVelocity, maxRadialVelocity));
                Vector2f.add(newVel, radialDir, newVel);
            }

            Vector2f newAcc = new Vector2f(
                    Utils.randBetween(minAcceleration.x, maxAcceleration.x),
                    Utils.randBetween(minAcceleration.y, maxAcceleration.y));
            Vector2f.add(newAcc, Utils.randomPointInCircle(new Vector2f(), accelerationSpread), newAcc);
            if (radialDir.lengthSquared() > 0f) {
                radialDir.normalise();
                radialDir.scale(Utils.randBetween(minRadialAcceleration, maxRadialAcceleration));
                Vector2f.add(newAcc, radialDir, newAcc);
            }

            float newSinXAmplitude = Utils.randBetween(minSinXAmplitude, maxSinXAmplitude);
            float newSinXFrequency = Utils.randBetween(minSinXFrequency, maxSinXFrequency) * twoPi;
            float newSinXPhase = Utils.randBetween(minSinXPhase, maxSinXPhase) * Misc.RAD_PER_DEG;
            float newSinYAmplitude = Utils.randBetween(minSinYAmplitude, maxSinYAmplitude);
            float newSinYFrequency = Utils.randBetween(minSinYFrequency, maxSinYFrequency) * twoPi;
            float newSinYPhase = Utils.randBetween(minSinYPhase, maxSinYPhase) * Misc.RAD_PER_DEG;

            float newTheta = Utils.randBetween(minTheta, maxTheta) * Misc.RAD_PER_DEG;
            float newW = Utils.randBetween(minW, maxW) * Misc.RAD_PER_DEG;
            float newAlpha = Utils.randBetween(minAlpha, maxAlpha) * Misc.RAD_PER_DEG;

            float newRadialW = Utils.randBetween(minRadialW, maxRadialW) * Misc.RAD_PER_DEG;
            float newRadialAlpha = Utils.randBetween(minRadialAlpha, maxRadialAlpha) * Misc.RAD_PER_DEG;

            float[] newSizeDataX = new float[3];
            float[] newSizeDataY = new float[3];
            for (int j = 0; j < 3; j++) {
                newSizeDataX[j] = Utils.randBetween(minSizeDataX[j], maxSizeDataX[j]);
                newSizeDataY[j] = Utils.randBetween(minSizeDataY[j], maxSizeDataY[j]);

            }

            float[] newStartColor = new float[4];
            for (int j = 0; j < 4; j++) {
                newStartColor[j] = startColor[j] + Utils.randBetween(-startColorRandom[j]/2f, startColorRandom[j]/2f);
            }

            float[] newColorShift = new float[4];
            for (int j = 0; j < 4; j++) {
                newColorShift[j] = Utils.randBetween(minColorShift[j], maxColorShift[j]);
            }

            float newFadeIn = Utils.randBetween(minFadeIn, maxFadeIn);
            float newFadeOut = Utils.randBetween(minFadeOut, maxFadeOut);
            float newLife = Utils.randBetween(minLife, maxLife);

            buffer.put(
                    new float[]{
                            newPos.x,
                            newPos.y,
                            location.x,
                            location.y,
                            emitterAngle,
                            newVel.x,
                            newVel.y,
                            newAcc.x,
                            newAcc.y,
                            newSinXAmplitude,
                            newSinXFrequency,
                            newSinXPhase,
                            newSinYAmplitude,
                            newSinYFrequency,
                            newSinYPhase,
                            newTheta,
                            newW,
                            newAlpha,
                            newRadialW,
                            newRadialAlpha,
                            newSizeDataX[0],
                            newSizeDataX[1],
                            newSizeDataX[2],
                            newSizeDataY[0],
                            newSizeDataY[1],
                            newSizeDataY[2],
                            newStartColor[0],
                            newStartColor[1],
                            newStartColor[2],
                            newStartColor[3],
                            newColorShift[0],
                            newColorShift[1],
                            newColorShift[2],
                            newColorShift[3],
                            newFadeIn,
                            newFadeOut,
                            startTime,
                            startTime + newLife
                    }
            );
        }
        buffer.flip();
        return buffer;
    }
}

package particleengine;

import com.fs.starfarer.api.combat.CombatEngineLayers;
import com.fs.starfarer.api.combat.ViewportAPI;
import com.fs.starfarer.api.graphics.SpriteAPI;
import com.fs.starfarer.api.util.Pair;
import org.lwjgl.BufferUtils;
import org.lwjgl.util.vector.Vector2f;

import java.nio.FloatBuffer;

/** Emitter interface. Extend to make custom particle emitters. */
public abstract class IEmitter {
    protected float lastParticleDeathTime = 0f;
    protected int indexInTracker = -1;
    protected boolean isDynamic = false;

    /**
     * @return Absolute location of this emitter, in world coordinates.
     * */
    public abstract Vector2f getLocation();

    /**
     * @return Sprite that particles from this emitter will have. Can be {@code null}, in which a default particle
     * will be used.
     */
    public abstract SpriteAPI getSprite();

    /**
     * @return Angle, in degrees, that this emitter's x-axis faces. If {@code 0}, then this emitter's
     * axes coincides with global axes (x-axis facing to the right).
     */
    public abstract float getXDir();

    /**
     * @return Source blend factor, e.g. {@code GL11.GL_SRC_ALPHA}.
     */
    public abstract int getBlendSourceFactor();
    /**
     * @return Destination blend factor, e.g. {@code GL11.GL_ONE_MINUS_SRC_ALPHA}.
     */
    public abstract int getBlendDestinationFactor();

    /**
     * @return Blending operation, e.g. {@code GL14.GL_FUNC_ADD}.
     */
    public abstract int getBlendFunc();

    /**
     * @return Layer particles should be rendered on.
     */
    public abstract CombatEngineLayers getLayer();

    /**
     * @return Distance from edge of screen beyond which particles are culled before generation.
     * This applies to the emitter's location rather than individual particles' locations.
     */
    public abstract float getRenderRadius();

    /**
     *  This function will be called before each burst of particles from this emitter is generated. All particles
     *  in a burst are generated at the same time, so this function may be used to pre-compute values that
     *  won't be changed throughout a burst.
     *
     *  @param startingIndex the index of first particle that is about to be generated in the incoming burst
     */
    protected abstract void preInitParticles(int startingIndex);

    /**
     * Construct parameters for a particle. Doesn't actually generate the particle. Use {@link Particles#burst}
     * to generate particles from an emitter.
     *
     * @param id Index of the particle in the burst or stream
     * @return Object containing the necessary data for particle generation
     */
    protected abstract ParticleData initParticle(int id);

    /**
     * Sets a flag that will allow particles generated by this emitter to dynamically follow its motion.
     */
    @SuppressWarnings("unused")
    public final void enableDynamicAnchoring() {
        isDynamic = true;
    }

    @SuppressWarnings("unused")
    public final void disableDynamicAnchoring() {
        isDynamic = false;
        untrack();
    }

    protected final int getIndexInTracker() {
        return indexInTracker;
    }

    protected final void untrack() {
        indexInTracker = -1;
    }

    /**
     * Prepare a {@link FloatBuffer} for particle generation.
     *
     * @param count Number of particles to generate
     * @param startIndex Starting index, which acts as a particle id that will be passed into {@link IEmitter#initParticle}
     * @param startTime Start of particles' life. Generally whatever the current time is when this method is called.
     * @param viewport Viewport object used to check if the emitter is in bounds
     * @return A pair. The first item in the pair is the {@link FloatBuffer} containing data for every particle.
     *  The second item in the pair is the maximum life of all the particles in this generation sequence.
     */
    protected final Pair<FloatBuffer, Float> generate(int count, int startIndex, float startTime, ViewportAPI viewport) {
        if (!Utils.isInViewport(getLocation(), viewport, getRenderRadius())) {
            return null;
        }
        if (isDynamic && indexInTracker == -1) {
            EmitterBufferHandler bufferHandler = Particles.getTrackedEmitterHandler();
            if (bufferHandler != null) {
                indexInTracker = bufferHandler.trackEmitter(this);
            }
        }
        FloatBuffer buffer = BufferUtils.createFloatBuffer(count * Particles.FLOATS_PER_PARTICLE);
        float maxLife = 0f;
        preInitParticles(startIndex);
        for (int i = 0; i < count; i++) {
            ParticleData data = initParticle(startIndex + i);
            if (data != null) {
                maxLife = Math.max(maxLife, data.life);
                data.addToFloatBuffer(this, startTime, buffer);
            }
        }
        lastParticleDeathTime = Math.max(lastParticleDeathTime, startTime + maxLife);
        buffer.flip();
        return new Pair<>(buffer, maxLife);
    }

}

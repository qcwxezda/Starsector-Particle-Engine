package particleengine;

import com.fs.starfarer.api.campaign.CampaignEngineLayers;
import com.fs.starfarer.api.campaign.listeners.CurrentLocationChangedListener;
import com.fs.starfarer.api.combat.CombatEngineLayers;
import com.fs.starfarer.api.combat.ViewportAPI;
import com.fs.starfarer.api.graphics.SpriteAPI;
import com.fs.starfarer.api.util.Pair;
import org.jetbrains.annotations.Nullable;
import org.lwjgl.BufferUtils;
import org.lwjgl.util.vector.Vector2f;

import java.nio.FloatBuffer;

/** Emitter interface. Extend to make custom particle emitters.*/
public abstract class IEmitter {
    protected int indexInTracker = -1;
    protected boolean isDynamic = false;
    protected boolean isSmoothDynamic = false;
    protected float lastCombatParticleDeathTime = 0f;
    protected float lastCampaignParticleDeathTime = 0f;

    protected float getLastParticleDeathTime() {
        if (Particles.isCombat()) {
            return Math.max(lastCombatParticleDeathTime, lastCampaignParticleDeathTime);
        }
        return lastCampaignParticleDeathTime;
    }

    /**
     * @return Absolute location of this emitter, in world coordinates.
     * */
    public abstract Vector2f getLocation();

    /**
     * @return Sprite that particles from this emitter will have. Can be {@code null}, in which a default particle
     * will be used.
     */
    public abstract SpriteAPI getSprite();

    /**
     * @return Angle, in degrees, that this emitter's x-axis faces. If {@code 0}, then this emitter's
     * axes coincides with global axes (x-axis facing to the right).
     */
    public abstract float getXDir();

    /**
     * @return Source blend factor, e.g. {@code GL11.GL_SRC_ALPHA}.
     */
    public abstract int getBlendSourceFactor();
    /**
     * @return Destination blend factor, e.g. {@code GL11.GL_ONE_MINUS_SRC_ALPHA}.
     */
    public abstract int getBlendDestinationFactor();

    /**
     * @return Blending operation, e.g. {@code GL14.GL_FUNC_ADD}.
     */
    public abstract int getBlendFunc();

    /**
     * @return Combat layer particles should be rendered on.
     */
    public abstract CombatEngineLayers getLayer();

    /**
     * @return Campaign layer particles should be rendered on.
     */
    public abstract CampaignEngineLayers getCampaignLayer();

    /**
     * @return Whether the particles should persist through campaign location transitions.
     * Note that particle and emitter positions are world-space-relative, not screen-space-relative, so
     * dynamic anchoring and changing emitters' positions in a {@link CurrentLocationChangedListener}
     * is required to fix particles' screen-space positions.
     */
    public abstract boolean isAlwaysRenderInCampaign();

    /**
     * @return Distance from edge of screen beyond which particles are culled before generation.
     * This applies to the emitter's location rather than individual particles' locations.
     */
    public abstract float getRenderRadius();

    /**
     *  This function will be called before each burst of particles from this emitter is generated. All particles
     *  in a burst are generated at the same time, so this function may be used to pre-compute values that
     *  won't be changed throughout a burst.
     *
     * @param start the index of first particle that is about to be generated in the incoming burst.
     * @param count the total number of particles that will be generated in the incoming burst.
     * @return whether to proceed with particle generation. If false, particles in the incoming burst are cancelled.
     */
    protected abstract boolean preInitParticles(int start, int count);

    /**
     * Construct parameters for a particle. Doesn't actually generate the particle. Use {@link Particles#burst}
     * to generate particles from an emitter.
     *
     * @param id Index of the particle in the burst or stream
     * @return Object containing the necessary data for particle generation
     */
    protected abstract ParticleData initParticle(int id);

    /**
     * Sets a flag that will allow particles generated by this emitter to dynamically follow its motion.
     */
    @SuppressWarnings("unused")
    public final void enableDynamicAnchoring() {
        isDynamic = true;
    }

    /**
     * Unsets the flag that allows particles generated by this emitter to dynamically follow its motion.
     */
    @SuppressWarnings("unused")
    public final void disableDynamicAnchoring() {
        isDynamic = false;
        untrack();
    }

    /**
     * @return Whether dynamic anchoring of particles is enabled
     */
    @SuppressWarnings("unused")
    public final boolean isDynamicAnchoring() {
        return isDynamic;
    }

    /**
     * @param isSmoothDynamic If enabled, particles will begin at their non-dynamic starting points and will end at their dynamic ending points.<br>
     *                        Can be used to, for example, create an absorption effect where particles are absorbed by their dynamically tracked entity.
     */
    @SuppressWarnings("unused")
    public final void setSmoothDynamic(boolean isSmoothDynamic) {
        this.isSmoothDynamic = isSmoothDynamic;
    }

    /**
     * @return Whether particles should begin at their non-dynamic starting points and end at their dynamic ending points
     */
    public final boolean isSmoothDynamic() {
        return isSmoothDynamic;
    }

    protected final int getIndexInTracker() {
        return indexInTracker;
    }

    protected final void untrack() {
        indexInTracker = -1;
    }

    /**
     * Prepare a {@link FloatBuffer} for particle generation.
     *
     * @param count Number of particles to generate
     * @param startIndex Starting index, which acts as a particle id that will be passed into {@link IEmitter#initParticle}
     * @param startTime Start of particles' life. Generally whatever the current time is when this method is called.
     * @param viewport Viewport object used to check if the emitter is in bounds
     * @return A pair. The first item in the pair is the {@link FloatBuffer} containing data for every particle.
     *  The second item in the pair is the maximum life of all the particles in this generation sequence.
     */
    protected final Pair<FloatBuffer, Float> generate(int count, int startIndex, float startTime, ViewportAPI viewport, boolean isCombat) {
        if (!Utils.isInViewport(getLocation(), viewport, getRenderRadius())) {
            return null;
        }
        if (!preInitParticles(startIndex, count)) {
            return null;
        }
        if (isDynamic && indexInTracker == -1) {
            EmitterBufferHandler bufferHandler = Particles.getTrackedEmitterHandler();
            if (bufferHandler != null) {
                indexInTracker = bufferHandler.trackEmitter(this);
            }
        }
        FloatBuffer buffer = BufferUtils.createFloatBuffer(count * Particles.FLOATS_PER_PARTICLE);
        float maxLife = 0f;
        for (int i = 0; i < count; i++) {
            ParticleData data = initParticle(startIndex + i);
            if (data != null) {
                maxLife = Math.max(maxLife, data.life);
                data.addToFloatBuffer(this, startTime, buffer);
            }
        }
        if (isCombat) {
            lastCombatParticleDeathTime = Math.max(lastCombatParticleDeathTime, startTime + maxLife);
        } else {
            lastCampaignParticleDeathTime = Math.max(lastCampaignParticleDeathTime, startTime + maxLife);
        }
        buffer.flip();
        return new Pair<>(buffer, maxLife);
    }

    /**
     * Generates an instantaneous burst of particles.
     *
     * @param count Number of particles to generate.
     * @return Whether the particles were successfully generated.
     */
    @SuppressWarnings("unused")
    public final boolean burst(int count) {
        return Particles.burst(this, count, 0);
    }

    /**
     * Generates a continuous stream of particles.
     *
     * @param particlesPerBurst  Number of particles that should be generated at once.
     * @param particlesPerSecond Total number of particles generated per second.
     * @param duration           Amount of time this particle stream should last. If negative, the stream will never expire.
     */
    public final void stream(int particlesPerBurst, float particlesPerSecond, float duration) {
        Particles.stream(this, particlesPerBurst, particlesPerSecond, duration, null);
    }


    /**
     * Generates a continuous stream of particles.
     *
     * @param particlesPerBurst  Number of particles that should be generated at once.
     * @param particlesPerSecond Total number of particles generated per second.
     * @param maxDuration        Maximum amount of time this particle stream should last. If negative, the stream
     *                           will not naturally expire.
     * @param doBeforeGenerating Custom function that's called immediately before each particle generation sequence in this stream.
     *                           Returning {@code false} will end the stream.
     */
    public final <T extends IEmitter> void stream(
            int particlesPerBurst,
            float particlesPerSecond,
            float maxDuration,
            @Nullable Particles.StreamAction<T> doBeforeGenerating) {
        //noinspection unchecked
        Particles.stream((T) this, particlesPerBurst, particlesPerSecond, maxDuration, doBeforeGenerating, null);
    }

    /**
     * Generates a continuous stream of particles.
     *
     * @param particlesPerBurst  Number of particles that should be generated at once.
     * @param particlesPerSecond Total number of particles generated per second.
     * @param maxDuration        Maximum amount of time this particle stream should last. If negative, the stream
     *                           will not naturally expire.
     * @param doBeforeGenerating Custom function that's called immediately before each particle generation sequence in this stream.
     *                           Returning {@code false} will end the stream.
     * @param doWhenFinished     Custom function that's called when the stream expires, which can occur either naturally, if
     *                           doBeforeGenerating returns {@code false}, or if the stream's emitter's anchor point is removed from play.
     *                           The return value is not used.
     */
    public final <T extends IEmitter> void stream(
            int particlesPerBurst,
            float particlesPerSecond,
            float maxDuration,
            @Nullable Particles.StreamAction<T> doBeforeGenerating,
            @Nullable Particles.StreamAction<T> doWhenFinished) {
        //noinspection unchecked
        Particles.stream((T) this, particlesPerBurst, particlesPerSecond, maxDuration, doBeforeGenerating, doWhenFinished);
    }
}
